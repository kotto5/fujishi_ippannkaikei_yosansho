# 学び - 令和6年度予算書JSON生成

## 1. JSON生成時に形式を統一すべき

### 問題
36個のJSONファイルを並列生成した結果、形式がバラバラになった：
- `{"項名": "市民税", "本年度予算額": ...}` (フラット形式)
- `{"市民税": {"本年度予算額": ...}}` (名前キー形式)
- 英語キー: `name`, `budget`, `items`, `targets`
- 様々な名称キー: `名称`, `項名`, `目名`, `名`, `名前`

### 失敗したアプローチ
`merge_json.py`で全ての形式を吸収しようとした。
→ 際限なくケースが増え、コードが複雑化した。

### 正しいアプローチ
1. **先に期待するJSON構造を定義する**（JSON_SPEC.md）
2. **バリデーションテストを作成する**（validate_json.py）
3. **テストをパスするまで生成を繰り返させる**

生成時に正しい形式を強制する方が、後から変換するより確実で早い。

---

## 2. バリデーションは「緩和」ではなく「スキップ」

### 問題
一部のJSONに`本年度予算額`がない款があった。
最初の対応：バリデーションを「required=False」に緩和した。

### 正しいアプローチ
構造が根本的に異なるデータには、そのテスト自体を**適用しない（スキップ）**。

```python
# NG: 緩和
errors.extend(validate_amount(data, "本年度予算額", required=False))

# OK: 条件付きスキップ
if data_type == "detailed_budget":
    errors.extend(validate_amount(data, "本年度予算額", required=True))
# そうでなければこのテストは実行しない
```

「緩和」するとテストの意味が薄れる。
「スキップ」すれば、該当するデータには厳密なテストが適用される。

---

## 3. 木構造データの共通パターン

予算書JSONの構造には共通パターンがある：

1. **ネストの深さが固定**：款 → 項 → 目 → 節
2. **各レベルで同じ形式**：`{"名称": {データ}}`
3. **配列の各要素は単一キー**：`[{"A": {...}}, {"B": {...}}]`

このパターンを意識してバリデーションを設計すべき。

```
{
  "款名": {           <- 単一キー
    "項": [           <- 配列
      {
        "項名": {     <- 単一キー
          "目": [...]
        }
      }
    ]
  }
}
```

---

## 4. 並列処理時のプロンプト統一

### 問題
36個のAgentに異なる款を処理させたら、各Agentが独自の解釈でJSONを生成した。

### 対策
- 期待する出力形式をプロンプトに明示する
- サンプルJSONを含める
- バリデーションスクリプトをAgentに渡し、自己検証させる

---

## 作成したツール

| ファイル | 用途 |
|---------|------|
| `validate_json.py` | JSONスキーマバリデーション |
| `fix_json_format.py` | フラット→名前キー形式変換 |
| `merge_simple.py` | シンプルなJSON統合 |
| `JSON_SPEC.md` | 期待するJSON構造の仕様書 |

---

---

## 5. 見開きPDFの処理：座標ベースマッチング

### 問題
予算書PDFは見開き2ページで1セット：
- 左ページ: 款・項・目の階層構造
- 右ページ: 節・説明・金額の詳細

OCRは「左ページ全部 → 右ページ全部」と読むため、Y軸の紐付けが失われる。

### 解決策: pdfplumber + Y座標マッチング

```python
# 見開き2ページを結合
left_words = left_page.extract_words()
right_words = right_page.extract_words()

# 右ページのX座標をオフセット
for w in right_words:
    w['x0'] += page_width

# Y座標でグループ化
y_groups = defaultdict(list)
for w in all_words:
    y = round(w['top'] / y_tolerance) * y_tolerance
    y_groups[y].append(w)
```

### 注意点
- Y tolerance は PDF のレイアウトに依存（今回は 12px が適切だった）
- 複数行に分割される場合がある（例: 款ヘッダーの名前と金額）
- ページ範囲は実際のPDFを確認して設定する

### 結果
- OCRベースより正確なデータ抽出が可能
- 歳入22款、歳出14款すべてバリデーション通過
- 左右ページの紐付けが正しく処理される

### 追加の注意点（v4で解決）

**1. 1つの目に複数の節がある場合**
```
目「個人」
  ├─ 節「現年課税分」
  │    ├─ 均等割
  │    └─ 所得割
  └─ 節「滞納繰越分」
       └─ 調定見込額
```
→ 目のY座標から次の目のY座標までの範囲にある節を全て収集

**2. 説明の階層構造**
右ページの説明は複数行にわたる：
```
y=145: 1 現年課税分 14,181,000 ...  ← 節の開始
y=170: 均等割 397,000               ← 説明（子項目）
y=190: 調定見込額 402,000×98.9％   ← 補足情報
y=210: 所得割 13,784,000            ← 説明（子項目）
```
→ 節番号で始まる行から次の節までを全てグループ化

---

## 作成したツール（更新）

| ファイル | 用途 |
|---------|------|
| `validate_json.py` | JSONスキーマバリデーション |
| `fix_json_format.py` | フラット→名前キー形式変換 |
| `merge_simple.py` | シンプルなJSON統合 |
| `JSON_SPEC.md` | 期待するJSON構造の仕様書 |
| `extract_budget_v3.py` | **座標ベースPDF抽出（推奨）** |

---

## 次回への教訓

1. **生成前にスキーマを定義する**
2. **バリデーションテストを先に書く**
3. **テストをパスするまで再生成させる**
4. **後から吸収しようとしない**
5. **見開きPDFは座標ベースで処理する**（pdfplumber + Y座標マッチング）
